% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Mifp.R
\name{Mifp}
\alias{Mifp}
\title{Iterative proportional fitting from matrix input}
\usage{
Mifp(x, z, iter = 100, yStart = matrix(1, nrow(x), 1), eps = 0.01,
  reduceBy0 = FALSE, reduceX = FALSE)
}
\arguments{
\item{x}{a matrix}

\item{z}{a single column matrix}

\item{iter}{maximum number of iterations}

\item{yStart}{a starting estimate of \code{y}}

\item{eps}{maximum allowed value of}

\item{reduceBy0}{Under work}

\item{reduceX}{Under work
\code{max(abs(z - t(x) \%*\% yHat))}}
}
\value{
\code{yHat}, the estimate of \code{y}
}
\description{
The linear equation, \code{z = t(x) \%*\% y}, is (hopefully)  solved for \code{y} by
iterative proportional fitting
}
\details{
The algorithm will work similar to \code{\link{loglin}} when the input x-matrix is a overparameterized model matrix 
â€“ as can be created by \code{\link{FormulaSums}}. See Examples.
}
\examples{
# Generate input data for loglin
n <- 5:9
tab <- array(sample(1:prod(n)), n)

# Input parameters
iter <- 20
eps <- 1e-05

# Estimate yHat by loglin
out <- loglin(tab, list(c(1, 2), c(1, 3), c(1, 4), c(1, 5), c(2, 3, 4), c(3, 4, 5)), 
              fit = TRUE, iter = iter, eps = eps)
yHatLoglin <- matrix(((out$fit)), ncol = 1)

# Transform the data for input to Pfifp
df <- as.data.frame.table(tab)
names(df)[1:5] <- c("A", "B", "C", "D", "E")
x <- FormulaSums(df, ~A:B + A:C + A:D + A:E + B:C:D + C:D:E - 1)
z <- t(x) \%*\% df$Freq

# Estimate yHat by Pfifp
yHatPfifp <- Mifp(x, z, iter = iter, eps = eps)

# Maximal absolute difference
max(abs(yHatPfifp - yHatLoglin))
}
