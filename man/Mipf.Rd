% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Mipf.R
\name{Mipf}
\alias{Mipf}
\title{Iterative proportional fitting from matrix input}
\usage{
Mipf(
  x,
  z,
  iter = 100,
  yStart = matrix(1, nrow(x), 1),
  eps = 0.01,
  tol = 1e-10,
  reduceBy0 = FALSE,
  reduceX = FALSE,
  returnDetails = FALSE,
  y = NULL,
  ordSplit = FALSE,
  altSplit = FALSE
)
}
\arguments{
\item{x}{a matrix}

\item{z}{a single column matrix}

\item{iter}{maximum number of iterations}

\item{yStart}{a starting estimate of \code{y}}

\item{eps}{stopping criterion. Maximum allowed value of \code{max(abs(z - t(x) \%*\% yHat))}}

\item{tol}{Another stopping criterion. Maximum absolute difference between two iteration.}

\item{reduceBy0}{When TRUE, \code{\link{ReduceBy0}}  used within the function}

\item{reduceX}{When TRUE, \code{\link{ReduceBy0}} and  \code{\link{ReduceXspes}} used within the function (iteratively)}

\item{returnDetails}{More output when TRUE. Quite similar to \code{\link{ReduceX}}}

\item{y}{It is possible to set \code{z} to NULL and supply original \code{y} instead  (\code{z = t(x) \%*\% y})}

\item{ordSplit}{Whether to order the pieces of the split x according to a rule}

\item{altSplit}{Whether to try alternative splitting when ordinary not working properly}
}
\value{
\code{yHat}, the estimate of \code{y}
}
\description{
The linear equation, \code{z = t(x) \%*\% y}, is (hopefully)  solved for \code{y} by
iterative proportional fitting
}
\details{
The algorithm will work similar to \code{\link{loglin}} when the input x-matrix is a overparameterized model matrix 
– as can be created by \code{\link{FormulaSums}}. See Examples.
}
\examples{
data2 <- EasyData("z2")
x <- FormulaSums(data2, ~fylke + kostragr * hovedint - 1)
z <- t(x) \%*\% data2$ant  # same as FormulaSums(data2, ant~fylke + kostragr * hovedint -1)
yHat <- Mipf(x, z)

#############################
# loglin comparison 
#############################

# Generate input data for loglin
n <- 5:9
tab <- array(sample(1:prod(n)), n)

# Input parameters
iter <- 20
eps <- 1e-05

# Estimate yHat by loglin
out <- loglin(tab, list(c(1, 2), c(1, 3), c(1, 4), c(1, 5), c(2, 3, 4), c(3, 4, 5)), 
              fit = TRUE, iter = iter, eps = eps)
yHatLoglin <- matrix(((out$fit)), ncol = 1)

# Transform the data for input to Mipf
df <- as.data.frame.table(tab)
names(df)[1:5] <- c("A", "B", "C", "D", "E")
x <- FormulaSums(df, ~A:B + A:C + A:D + A:E + B:C:D + C:D:E - 1)
z <- t(x) \%*\% df$Freq

# Estimate yHat by Mipf
yHatPMipf <- Mipf(x, z, iter = iter, eps = eps)

# Maximal absolute difference
max(abs(yHatPMipf - yHatLoglin))

# Note: loglin reports one iteration extra 

# Another example. Only one iteration needed.
max(abs(Mipf(x = FormulaSums(df, ~A:B + C - 1), 
             z = FormulaSums(df, Freq ~ A:B + C -1)) 
             - matrix(loglin(tab, list(1:2, 3), fit = TRUE)$fit, ncol = 1)))


#########################################
#  reduceBy0  and  reduceX examples 
#########################################

#' z3 <- EasyData("z3")
x <- FormulaSums(z3, ~region + kostragr * hovedint + region * mnd2 + fylke * mnd + 
                     mnd * hovedint + mnd2 * fylke * hovedint - 1)

# Reduction by 0, but no iteration improvement. Identical results.
t <- 360
y <- z3$ant
y[round((1:t) * 432/t)] <- 0
z <- t(x) \%*\% y
a1 <- Mipf(x, z, eps = 0.1)
a2 <- Mipf(x, z, reduceBy0 = TRUE, eps = 0.1)
a3 <- Mipf(x, z, reduceX = TRUE, eps = 0.1)
max(abs(a1 - a2))
max(abs(a1 - a3))


# Improvement by reduceX. Changing eps and iter give more similar results.
t <- 402
y <- z3$ant
y[round((1:t) * 432/t)] <- 0
z <- t(x) \%*\% y
a1 <- Mipf(x, z, eps = 1)
a2 <- Mipf(x, z, reduceBy0 = TRUE, eps = 1)
a3 <- Mipf(x, z, reduceX = TRUE, eps = 1)
max(abs(a1 - a2))
max(abs(a1 - a3))

# Example with small eps and "Iteration stopped since tol reached"
t <- 384
y <- z3$ant
y[round((1:t) * 432/t)] <- 0
z <- t(x) \%*\% y
a1 <- Mipf(x, z, eps = 1e-14)
a2 <- Mipf(x, z, reduceBy0 = TRUE, eps = 1e-14)
a3 <- Mipf(x, z, reduceX = TRUE, eps = 1e-14)
max(abs(a1 - a2))
max(abs(a1 - a3))

# All y-data found by reduceX (0 iterations). 
t <- 411
y <- z3$ant
y[round((1:t) * 432/t)] <- 0
z <- t(x) \%*\% y
a1 <- Mipf(x, z)
a2 <- Mipf(x, z, reduceBy0 = TRUE)
a3 <- Mipf(x, z, reduceX = TRUE)
max(abs(a1 - y))
max(abs(a2 - y))
max(abs(a3 - y))
}
\author{
Øyvind Langsrud
}
